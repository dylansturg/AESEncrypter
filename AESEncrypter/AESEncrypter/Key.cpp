#include "stdafx.h"

#include "Key.h"
#include "SBox.h"

#include <sstream>
#include <iostream>
#include <iomanip>

vector<unsigned char> ColumnXor(vector<unsigned char>, vector<unsigned char>);
void rotateVector(vector<unsigned char> &);
void byteSubVector(vector<unsigned char>&);
unsigned char calculateRoundConstant(int);

Key::Key()
{
}

Key::Key(vector<unsigned char> key)
{
	this->matrix.resize(16);
	for (int row = 0; row < 4; row++){
		for (int col = 0; col < 4; col++){
			this->matrix[row * 4 + col] = key[col * 4 + row];
		}
	}

	CalculateExtendedKey();
}

Key& Key::operator=(Key rhs){
	this->matrix.clear();
	this->extendedKey.clear();

	this->matrix.insert(this->matrix.begin(), rhs.matrix.begin(), rhs.matrix.end());
	this->extendedKey.insert(this->extendedKey.begin(), rhs.extendedKey.begin(), rhs.extendedKey.end());
	return *this;
}

void Key::CalculateExtendedKey()
{
	this->extendedKey.insert(this->extendedKey.begin(), this->matrix.begin(), this->matrix.end());
	this->extendedKey.resize(176, 0);

	for (int i = 4; i < 44; i++)
	{
		vector<unsigned char> backFour = GetColumn(i - 4);
		vector<unsigned char> backOne = GetColumn(i - 1);

		if (i % 4 == 0){
			rotateVector(backOne);
			byteSubVector(backOne);
			unsigned char roundConst = calculateRoundConstant(i);
			backOne[0] ^= roundConst;

			SetColumn(ColumnXor(backFour, backOne), i);
		}
		else {

			SetColumn(ColumnXor(backFour, backOne), i);
		}
	}
}

vector<unsigned char> Key::GetRoundKey(int round)
{
	vector<unsigned char> roundKey;
	roundKey.resize(16);
	for (int i = 0; i < 4; i++)
	{
		vector<unsigned char> col = GetColumn(4 * round + i);
		for (int j = 0; j < 4; j++)
		{
			roundKey[j * 4 + i] = col[j];
		}
	}
	return roundKey;
}

vector<unsigned char> Key::GetColumn(int colInd)
{
	vector<unsigned char> col;
	for (int i = 0; i < 4; i++)
	{
		col.push_back(this->extendedKey[colInd*4 + i]);
	}
	return col;
}

void Key::SetColumn(vector<unsigned char> col, int colInd)
{
	for (int i = 0; i < 4; i++)
	{
		this->extendedKey[colInd*4 + i] = col[i];
	}
}

string Key::Dump(){
	stringstream res;

	for (int i = 0; i < 11; i++){
		for (int j = 0; j < 16; j++){
			res << setfill('0') << setw(2) << hex << (int)this->extendedKey[i * 16 + j];
			res << " ";
		}
		res << endl;

	}
	return res.str();
}

vector<unsigned char> ColumnXor(vector<unsigned char> x, vector<unsigned char> y)
{
	vector<unsigned char> res;
	res.resize(4);
	for (int i = 0; i < 4; i++)
	{
		res[i] = x[i] ^ y[i];
	}
	return res;
}

void rotateVector(vector<unsigned char> & vec)
{
	vector<unsigned char> temp;
	temp.insert(temp.begin(), vec.begin(), vec.end());

	vec[0] = temp[1];
	vec[1] = temp[2];
	vec[2] = temp[3];
	vec[3] = temp[0];
}

void byteSubVector(vector<unsigned char>& vec)
{
	SBox converter;
	for (int i = 0; i < 4; i++)
	{
		vec[i] = converter.ConvertByte(vec[i]);
	}
}

unsigned char calculateRoundConstant(int round)
{
	// Taken from http://en.wikipedia.org/wiki/Rijndael_key_schedule
	unsigned char Rcon[256] = {
		0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
		0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
		0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
		0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
		0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
		0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
		0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
		0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
		0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
		0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
		0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
		0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
		0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
		0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
		0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
		0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d };

	return Rcon[((round - 4) / 4) + 1];
}